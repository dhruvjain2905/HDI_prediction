# -*- coding: utf-8 -*-
"""Final_Data_Processing

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/169p-d1qoFHlAU57WUQrICGmIWxqJ4zN7
"""

from google.colab import drive
drive.mount('/content/drive')

import geopandas as gpd
data = gpd.read_file("/content/drive/MyDrive/GDL Shapefiles V6.1/shdi2022_World_large.shp")

points = data.copy()
points.crs =data.crs
points = points.rename(columns={'gdlcode': 'GDLCODE'})

import pandas as pd
import numpy as np

shdi = pd.read_csv("/content/drive/MyDrive/GDL-Subnational-HDI-data (1).csv")
shdi

merged = pd.merge(points, shdi, how = "right", on="GDLCODE")

merged = merged.dropna(subset = ["geometry"])

merged[merged['geometry'].isna()]

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_8.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

new_data.shape
sum(sum(new_data))

np.save('d2.npy', new_data)

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_A1.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2
        pixel_y = (upper+lower)/2
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]  # Convert the tile to a NumPy array

# Display the resulting DataFrame

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(1129)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

max[hdi_data.population]

df.to_csv("A1df.csv")

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_2.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_B1.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +21600
        pixel_y = (upper+lower)/2
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]  # Convert the tile to a NumPy array

# Display the resulting DataFrame

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(1653)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

df.head(5)

df.to_csv("B1df.csv")

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_3.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_C1.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +43200
        pixel_y = (upper+lower)/2
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]  # Convert the tile to a NumPy array

# Display the resulting DataFrame

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(5946)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

main_arr = np.array([i for i in df["pixel_values"]])

np.save("mainarr", main_arr)

df.to_csv("C1df.csv")

df.head(5)

max(df.hdi)

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_4.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

new_data.shape

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_D1.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +64800
        pixel_y = (upper+lower)/2
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(2191)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

df.head(5)

df[df["hdi"] == 0]
max(df["population"])

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

df.to_csv("D1df.csv")

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_6.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

new_data.shape

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_B2.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +21600
        pixel_y = (upper+lower)/2 + 21600
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(1564)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

df[df["hdi"] == 0]

df

df.population.sum()

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

df[df["hdi"] == 0]

max(df.hdi)

df.to_csv("B2df.csv")

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_7.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

new_data.shape

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_C2.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +43200
        pixel_y = (upper+lower)/2 + 21600
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(1188)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

df[df.hdi == 0]

sum(df.population)

df.to_csv("C2df.csv")

import numpy as np

#data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2020_1_deg.asc")
data = np.loadtxt("/content/drive/MyDrive/gpw_v4_population_count_rev11_2015_30_sec_8.asc")

data[data == -9999] = 0

new_shape = (108, 108)
new_data = data.reshape(new_shape[0], 100, new_shape[1], 100).sum(axis=(1, 3))

import numpy as np
import pandas as pd
from PIL import Image

# Load the large image
Image.MAX_IMAGE_PIXELS = None
image = Image.open("/content/drive/MyDrive/BlackMarble_2016_D2.jpeg")

# Define the desired size of the smaller pieces
tile_width = 200
tile_height = 200
image_width = 86400
image_height = 43200
# Calculate the number of rows and columns needed to divide the image into tiles
num_tiles_horizontal = image.width // tile_width
num_tiles_vertical = image.height // tile_height

# Create an empty DataFrame to store the pixel values
df = pd.DataFrame(columns=['pixel_values', "coordinates", "population"])

# Iterate over each tile and save them as separate images
for i in range(num_tiles_vertical):
    for j in range(num_tiles_horizontal):
        left = j * tile_width
        upper = i * tile_height
        right = left + tile_width
        lower = upper + tile_height
        pixel_x = (left+right)/2 +64800
        pixel_y = (upper+lower)/2 + 21600
        population = new_data[i, j]
        tile = image.crop((left, upper, right, lower))
        longitude = (pixel_x / image_width) * 360 - 180
        latitude = ((pixel_y / image_height) * 180 - 90) * -1
        #print(f"({left}, {upper}) , ({right}, {lower})   center({pixel_x} , {pixel_y}) coor({latitude}, {longitude})")


        tile_array = np.array(tile)
        if population > 5000:
          df.loc[len(df.index)] = [tile_array, [latitude, longitude], population]

len(df)

import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point

#random_images = df.sample(n=238)  # Adjust the number as needed and set random_state for reproducibility
#indexes = random_images.index
# Display the random images using matplotlib

last = 1
country = 1
df["hdi"] = [0 for i in range(696)]

for i in df.index:
    #image_array = df['pixel_values'].iloc[i]  # Get the pixel values of the image
    #image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    #plt.imshow(image_array)
    #plt.show()

    min_distance = float("inf")
    done = True

    if merged.loc[last, "geometry"].contains(Point(df.loc[i,"coordinates"][::-1])):
      print(merged.loc[last, "2016"], "last shape")
      df.loc[i, "hdi"] = merged.loc[last, "2016"]
      done = False

    if done:
      new_merged = merged[merged["Country"] == merged.loc[country, "Country"]]
      for t in new_merged.index:
        c = new_merged.loc[t, "geometry"]
        if c.contains(Point(df.loc[i,"coordinates"][::-1])):
          print(new_merged.loc[t, "2016"], "last country")
          df.loc[i, "hdi"] = new_merged.loc[t, "2016"]
          last = t
          done = False
          break


    if done:

      if merged["geometry"].contains(Point(df.loc[i,"coordinates"][::-1])).any():
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          if check.contains(Point(df.loc[i,"coordinates"][::-1])):
            print(merged.loc[t, "2016"], "normal")
            df.loc[i, "hdi"] = merged.loc[t, "2016"]
            last = t
            country = t
            done = False
            break

      else:
        for t in merged.index:

          check = merged.loc[t, "geometry"]

          point = Point(df.loc[i,"coordinates"][::-1])
          distance = point.distance(check.boundary)
          if distance < min_distance:
            min_distance = distance
            poly = t


        print(merged.loc[poly, "2016"], "min dist")
        df.loc[i, "hdi"] = merged.loc[poly, "2016"]






    print(df.loc[i,"population"])
    print(df.loc[i,"coordinates"])

df[df.hdi == 0]

max(df.hdi)

sum(df.population)

max(df.population)

random_images = df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])

df.to_csv("D2df.csv")



b1df = pd.read_csv("/content/B1df.csv")
for i in b1df.index:
  list_of_lists = [list(map(int, line.strip(' []').split(','))) for line in b1df.loc[i, "pixel_values"].strip().split('\n')]
    # Convert the list of lists to a NumPy array
  list_of_lists = np.array(list_of_lists)
  b1df.loc[i, "pixel_values"] = list_of_lists

print(b1df.loc[1, "pixel_values"])
type(b1df.loc[1, "pixel_values"])



random_images = b1df.sample(n=10)  # Adjust the number as needed and set random_state for reproducibility
indexes = random_images.index
# Display the random images using matplotlib




for i in random_images.index:
    image_array = random_images.loc[i, 'pixel_values'] # Get the pixel values of the image
    image = Image.fromarray(image_array)  # Create a PIL Image object from the pixel values
    plt.imshow(image_array)
    plt.show()
    print(random_images.loc[i, "population"])
    print(random_images.loc[i, "coordinates"])
    print(random_images.loc[i, "hdi"])